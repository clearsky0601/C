# 动态内存管理

## 学习目标
- 掌握动态内存分配和释放
- 理解堆内存和栈内存的区别
- 学会避免内存泄漏和悬空指针
- 了解内存管理的最佳实践

## 知识要点

### 内存分配函数

#### 1. malloc函数
```c
void *malloc(size_t size);
```
- 分配指定字节数的内存
- 返回void指针，需要类型转换
- 分配失败返回NULL

#### 2. calloc函数
```c
void *calloc(size_t num, size_t size);
```
- 分配num个size字节的内存块
- 自动初始化为0
- 适合数组分配

#### 3. realloc函数
```c
void *realloc(void *ptr, size_t new_size);
```
- 重新调整内存块大小
- 可能移动内存位置
- 保留原有数据

#### 4. free函数
```c
void free(void *ptr);
```
- 释放动态分配的内存
- 必须与malloc/calloc/realloc配对使用
- 释放后指针变为悬空指针

### 内存管理原则

#### 1. 分配与释放配对
- 每个malloc都要有对应的free
- 避免重复释放同一块内存
- 释放后将指针设为NULL

#### 2. 检查分配结果
```c
int *ptr = malloc(sizeof(int) * 100);
if (ptr == NULL) {
    // 处理分配失败
    return -1;
}
```

#### 3. 避免内存泄漏
- 函数返回前释放所有分配的内存
- 异常退出路径也要释放内存
- 使用工具检测内存泄漏

### 常见错误

#### 1. 内存泄漏
- 分配后忘记释放
- 异常路径未释放
- 重复分配覆盖指针

#### 2. 悬空指针
- 释放后继续使用指针
- 返回局部变量地址
- 多次释放同一指针

#### 3. 缓冲区溢出
- 访问超出分配范围
- 数组边界检查
- 字符串操作安全

### 动态数据结构

#### 1. 动态数组
```c
int *arr = malloc(sizeof(int) * size);
// 使用完毕后
free(arr);
arr = NULL;
```

#### 2. 动态字符串
```c
char *str = malloc(strlen(source) + 1);
strcpy(str, source);
// 使用完毕后
free(str);
```

#### 3. 动态结构体
```c
struct Person *p = malloc(sizeof(struct Person));
// 初始化和使用
free(p);
```

### 内存调试

#### 1. 调试工具
- Valgrind（Linux/macOS）
- AddressSanitizer
- 静态分析工具

#### 2. 调试技巧
- 使用调试版本的内存分配器
- 添加内存分配日志
- 定期检查内存使用情况

### 最佳实践

#### 1. RAII原则
- 获取资源即初始化
- 作用域结束时自动释放
- 使用包装函数管理内存

#### 2. 错误处理
- 检查所有分配结果
- 提供清理函数
- 异常安全的代码设计

## 代码说明
本目录包含动态内存管理的完整演示，展示正确的内存管理技术。

## 编译运行
```bash
make
make run
make debug    # 调试版本
```

## 练习建议
1. 实现动态数组数据结构
2. 编写内存池分配器
3. 实现字符串处理函数
4. 创建链表等动态数据结构

## 常见错误
1. **内存泄漏**：忘记释放分配的内存
2. **悬空指针**：使用已释放的内存
3. **重复释放**：多次释放同一块内存
4. **缓冲区溢出**：访问超出分配范围

## 下一步学习
完成本节后，请继续学习：
- 03-preprocessor：预处理器
